# -*- coding: utf-8 -*-
"""Bank_loan_analysis(Default prediction).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gnjv_45iwzQG4q6KDD33s2jKxvx-KvBy
"""

# Commented out IPython magic to ensure Python compatibility.
#import all libraries 
import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt 
import matplotlib.style as style
import itertools
import seaborn as sns 
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

application_data = pd.read_csv("/content/drive/MyDrive/application_data.csv")

"""DATA CLEANING"""

application_data.head()

application_data.info()

application_data.describe()

application_data.isnull().sum()

application_data.info(verbose=True)

application_data = application_data.dropna(0)

application_data

application_data.isnull().sum()

prev_application = pd.read_csv("/content/drive/MyDrive/previous_application.csv")

prev_application.head()

prev_application.describe()

prev_application.info()

prev_application.isnull().sum()

application_data.value_counts

"""EXPLORATORY DATA ANALYSIS"""

#univariate distribution
plt.figure(figsize=(6,6))
sns.kdeplot(application_data['AMT_ANNUITY'])
plt.show()

plt.figure(figsize=(6,6))
sns.kdeplot(prev_application['AMT_ANNUITY'])
plt.show()

#there is single point distribution found in previous application data because there are null values are in dataset 
#so thst we impute these null values by meadian 
prev_application['AMT_ANNUITY'].fillna(prev_application['AMT_ANNUITY'].median(),inplace = True)

#Impute AMT_GOODS_PRICE with mode as the distribution is closely similar:
plt.figure(figsize=(6,6))
sns.kdeplot(prev_application['AMT_GOODS_PRICE'][pd.notnull(prev_application['AMT_GOODS_PRICE'])])
plt.show()

#similarly we can check in application data 
plt.figure(figsize=(6,6))
sns.kdeplot(application_data['AMT_GOODS_PRICE'][pd.notnull(application_data['AMT_GOODS_PRICE'])])
plt.show()

#we can replcae missing values wth mode from the above figure and have value counts 
prev_application['AMT_GOODS_PRICE'].fillna(prev_application['AMT_GOODS_PRICE'].mode()[0], inplace=True)
prev_application.loc[prev_application['CNT_PAYMENT'].isnull(),'NAME_CONTRACT_STATUS'].value_counts()

''' we can find the outliers in the application data by using boxplot as there are many outliers are present in it 
similarly we can find the outliers in the prev_application_data'''
plt.figure(figsize=(22,10))

app_outlier_col_1 = ['AMT_ANNUITY','AMT_INCOME_TOTAL','AMT_CREDIT','AMT_GOODS_PRICE','DAYS_EMPLOYED']
app_outlier_col_2 = ['CNT_CHILDREN','DAYS_BIRTH']
for i in enumerate(app_outlier_col_1):
    plt.subplot(2,4,i[0]+1)
    sns.boxplot(y=application_data[i[1]])
    plt.title(i[1])
    plt.ylabel("")

for i in enumerate(app_outlier_col_2):
    plt.subplot(2,4,i[0]+6)
    sns.boxplot(y=application_data[i[1]])
    plt.title(i[1])
    plt.ylabel("")

plt.figure(figsize=(22,8))
prev_outlier_col_1 = ['AMT_ANNUITY','AMT_APPLICATION','AMT_CREDIT','AMT_GOODS_PRICE','SELLERPLACE_AREA']
prev_outlier_col_2 = ['SK_ID_CURR','DAYS_DECISION','CNT_PAYMENT']
for i in enumerate(prev_outlier_col_1):
    plt.subplot(2,4,i[0]+1)
    sns.boxplot(y=prev_application[i[1]])
    plt.title(i[1])
    plt.ylabel("")

for i in enumerate(prev_outlier_col_2):
    plt.subplot(2,4,i[0]+6)
    sns.boxplot(y=prev_application[i[1]])
    plt.title(i[1])
    plt.ylabel("")

Repayer = application_data.loc[application_data['TARGET']==0] # Repayers
Defaulter = application_data.loc[application_data['TARGET']==1] # Defaulters

# In the following session we are going to perfomr a analysis on by merging two files

loan_process = pd.merge(application_data, prev_application, how='inner', on='SK_ID_CURR')
loan_process.head()

#plot contract status and purpose of the loan 
loan_process.describe()

#we can find the information about the loan_process 
loan_process.info(verbose=True)

#Now here is the main step we can separate the repayer and Defaulter and give the specific value in terms of 0 and 1
Repayer = application_data.loc[application_data['TARGET']==0] # Repayers
Defaulter = application_data.loc[application_data['TARGET']==1] # Defaulters

print(loan_process.corr())

#with the help of Histogram we can clearly see the defaulters 
plt.hist(loan_process['TARGET'], bins=50)

sns.jointplot(x = 'TARGET', y = 'AMT_INCOME_TOTAL', data = loan_process)

application_data["TARGET"].head()

"""**MODEL Evaluation**"""

Repayer = application_data.loc[application_data['TARGET']==0] # Repayers
Defaulter = application_data.loc[application_data['TARGET']==1] # Defaulters

X = application_data["ID"].values
y = application_data["TARGET"].values

X = X.reshape(-1,1)
X = X.reshape(-1,1)

import statsmodels.api as sm
logit_model=sm.Logit(y,X)
result=logit_model.fit()
print(result.summary2())

'''import numpy as np
X = tuple(range(8076))
X = np.asarray(X)
y=tuple(range(8076))
y = np.asarray(y)'''

'''X_train = X_train.reshape(-1,1)
y_train = X_train.reshape(-1,1)
X_test = X_test.reshape(-1,1)
X_test = X_test.reshape(-1,1)'''

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)
logreg = LogisticRegression()
model = logreg.fit(X_train, y_train)

y_pred = logreg.predict(X_test)
print('Accuracy of logistic regression classifier on test set: {:.2f}'.format(logreg.score(X_test, y_test)))

from sklearn.metrics import confusion_matrix
confusion_matrix = confusion_matrix(y_test, y_pred)
cm = print(confusion_matrix)

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred))

from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
logit_roc_auc = roc_auc_score(y_test, logreg.predict(X_test))
fpr, tpr, thresholds = roc_curve(y_test, logreg.predict_proba(X_test)[:,1])
plt.figure()
plt.plot(fpr, tpr, label='Logistic Regression (area = %0.2f)' % logit_roc_auc)
plt.plot([0, 1], [0, 1],'r--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic')
plt.legend(loc="lower right")
plt.savefig('Log_ROC')
plt.show()

X_test

y_pred = model.predict(X_test)

y_pred

pip install streamlit

import streamlit as st 
st.sidebar.subheader("Choose classifier")
classifier = st.sidebar.selectbox("Classifier",( "Logistic Regression"))

import pickle
pickle.dump(model, open('Bank_loan_analysis.pickle', 'wb'))

import pickle
from flask import Flask, request, jsonify, render_template

# load model
model = pickle.load(open('model.pkl','rb'))

# app
app = Flask(__name__)

# routes
@app.route('/', methods=['POST'])

def predict():
    # get data
    data = request.get_json(force=True)

    # convert data into dataframe
    data.update((X, [y]) for X, y in data.items())
    data_df = pd.DataFrame.from_dict(application_data)

    # predictions
    result = model.predict(data_df)

    # send back to browser
    output = {'results': int(result[0])}

    # return data
    return jsonify(results=output)

if __name__ == '__main__':
    app.run(port = 5000, debug=True)

"""THE ABOVE APPLICATION MAY NOT BE WORK ON SOME ENVIORNMENT , BUT WE SHOULD TEST THE APPLICATION BY METHOD BELOW

CREATE URL LOCALLY
"""

#local url
url = 'http://127.0.0.1:5000'

"""CREATE SAMPLE DATA LOCALLY AND JASONIFY IT"""

# sample data
import json
data = {'ID': 72
      ,
       'TARGET': 0
      ,
      }
data = json.dumps(data)

"""SEND REQUEST"""

import requests
send_request = requests.post(url, data)
print(send_request)

"""NOW YOU WILL GET RESULT """

print(send_request.json())

pip freeze > requirements.txt

''' After analysing the datasets, there are few attributes of a client with which the bank would be able to 
identify if they will repay the loan or not.
main attributes from which bank can analyse the whole process that
1. NAME_HOUSING_TYPE
2. AMT_INCOME
3. AMT_CREDIT
4. CNT_CHILDREN AND CNT_FAM_MEMBERS
5.NAME_CASH_LOAN_PURPOSEB 
There are reasons behind rejecting the loan process by bank to many customers. 
 1. Either they are paying lately. Or they are paying with due amount. 
 2. Or they are not fit for  the terms and conditions of the bank. '''

